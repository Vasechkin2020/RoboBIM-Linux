У тебя набрался солидный набор параметров. Чтобы ты не запутался, я разделил их по **нодам** и по **физическому смыслу**.

Всего у тебя **12 ключевых "крутилок"**, которые влияют на поведение робота.

---

### 1. `pos_node` (Где я?)
*Отвечает за точность координат и плавность линий на графике.*

#### А. Слияние и Задержки (Самое важное)
1.  **`lidar_latency_L`** (в `main.cpp`)
    *   *Сейчас:* `0.15` (сек).
    *   *Что делает:* Компенсирует отставание лидара.
    *   *Настройка:* Если робот переезжает цель (по `est`), увеличивай. Если недоезжает — уменьшай.
2.  **`gain`** (в `localizer.h`, внутри `RateLimitedLocalizer`)
    *   *Сейчас:* `0.333` (33%).
    *   *Что делает:* Насколько агрессивно оценка (`est`) прыгает к данным лидара.
    *   *Настройка:* Если `est` слишком "зубастая" (пила) — уменьшай (до 0.1). Если вялая — увеличивай.
3.  **`max_angle_step`** (в `localizer.h`)
    *   *Сейчас:* `1.0` (град).
    *   *Что делает:* Лимит скорости исправления ошибки угла. Защита от телепортации при сбое лидара.

#### Б. Синхронизация (Связь Est и Model)
4.  **`k_motion` / `k_soft_sync`** (в `main.cpp`, блок Soft Sync)
    *   *Сейчас:* `0.025` (2.5%).
    *   *Что делает:* Насколько сильно `model` (одометрия) тянется к `est` на ходу.
    *   *Настройка:* Должен быть равен примерной погрешности твоей механики. Если поставить `0`, модель улетит в бесконечность.
5.  **Таймеры стоянки** (в `main.cpp`)
    *   *Сейчас:* `0.5с` (старт медианы), `1.9с` (сброс модели).
    *   *Что делает:* Определяет, как долго робот должен стоять неподвижно, чтобы мы поверили, что позиция железобетонная, и сбросили дрейф.

#### В. Физика сенсоров (IMU + Колеса)
6.  **`alpha`** (в `code.h`, Leaky Integrator)
    *   *Сейчас:* `0.98`.
    *   *Что делает:* Борьба с дрейфом акселерометра. 98% верим инерции, 2% верим, что скорость колес верна.
7.  **Веса слияния** (в `code.h`, `calcTwistFused`)
    *   *Сейчас:* `0.05` / `0.95` (для угла).
    *   *Что делает:* Кому верим больше: гироскопу или энкодерам.

---

### 2. `control_node` (Куда ехать?)
*Отвечает за то, как робот исполняет команды.*

#### А. Точность остановки
8.  **`margin`** (в `code.h`, `calculate_max_safe_speed`)
    *   *Сейчас:* `0.01` (10 мм).
    *   *Что делает:* Зона "подкрадывания". За 10 мм до цели робот сбрасывает расчетную скорость в 0 и ползет на минималке.
9.  **`minVectorMistake` / `minAngleMistake`** (в `code.h`)
    *   *Сейчас:* `0.001` м (1 мм) / `0.02` град.
    *   *Что делает:* Условие финиша.

#### Б. Динамика (Разгон/Торможение)
10. **`max_angular_acceleration_degs2`** (в `code.h`)
    *   *Сейчас:* `15.0` (град/с²).
    *   *Что делает:* Плавность старта и торможения при поворотах. Меньше = плавнее, но медленнее.
11. **`max_deceleration`** (в `code.h`)
    *   *Сейчас:* `0.1` (м/с²).
    *   *Что делает:* Тормозной путь при езде прямо. Если робот пролетает цель и резко бьет по тормозам — это число слишком большое для твоего веса/пола.

#### В. Рулежка (L1 Controller)
12. **`L_lookahead`** (в `code.h`, `workVector`)
    *   *Сейчас:* `0.4` (метра).
    *   *Что делает:* Как далеко вперед смотрит робот при езде по прямой.
    *   *Настройка:*
        *   Мало (0.1): Робот будет вилять, пытаясь вернуться на линию каждые 10 см.
        *   Много (1.0): Робот будет ехать очень плавно, но может "срезать углы" или медленно возвращаться на траекторию, если его сдвинуть. `0.4` — золотая середина для комнатных скоростей.

### Итого
Самые важные для тебя сейчас (для точности чертежа):
1.  **`lidar_latency_L`** (чтобы не было перелетов).
2.  **`DISTANCE_WHEELS`** (в конфиге, чтобы 90 градусов были 90 градусами).
3.  **`margin`** (чтобы мягко доезжать до точки).


==============================================================================================
Это полное техническое резюме проекта по разработке системы навигации и управления для дифференциального робота-чертежника.

В документе систематизированы архитектура, алгоритмы, математические модели, проблемы, с которыми мы столкнулись, и финальные решения, внедренные в код.

---

# Техническое Резюме Проекта: RoboBIM Navigation Stack

**Версия:** 1.05 (Final Tuning)
**Платформа:** ROS (Robot Operating System) / Raspberry Pi
**Кинематика:** Дифференциальный привод (Differential Drive)
**Основная задача:** Высокоточное перемещение и черчение фигур на плоскости по G-коду с компенсацией дрейфа и задержек.

---

## 1. Архитектура Системы

Система разделена на два основных узла (Node), реализующих принцип **"Разделения ответственности"**:

1.  **`pos_node` (Localization):** Отвечает за ответ на вопрос *"Где я?"*. Занимается слиянием датчиков (Sensor Fusion), фильтрацией шума и расчетом текущей позы.
2.  **`control_node` (Execution):** Отвечает за ответ на вопрос *"Куда и как ехать?"*. Парсит G-код, рассчитывает траектории, управляет скоростями колес через L1-контроллер.

---

## 2. Узел Локализации (`pos_node`)

Это сердце системы. Мы отказались от стандартных EKF (Extended Kalman Filter) в пользу кастомного каскадного фильтра, оптимизированного под специфику лидара и задержек.

### 2.1. Иерархия Систем Координат
Мы выделили три уровня абстракции позиции, которые рассчитываются параллельно:

1.  **`ODOM` (Одометрия):**
    *   **Источник:** Только энкодеры колес.
    *   **Свойства:** Идеальная плавность, но накапливает ошибку (дрейф) бесконечно.
    *   **Назначение:** Используется для микро-маневров (отъезд пера) и диагностики проскальзывания.
2.  **`MODEL` (Инерциальная Модель):**
    *   **Источник:** Энкодеры + IMU (Гироскоп/Акселерометр).
    *   **Алгоритм:**
        *   Угол берется на **95% с гироскопа**, 5% с колес.
        *   Линейная скорость: **Leaky Integrator** (`alpha=0.98`), который на 98% верит инерции (акселерометру) и на 2% подтягивается к колесам.
    *   **Свойства:** Очень плавная (как одометрия), но держит угол намного точнее. Не боится пробуксовки одного колеса.
    *   **Синхронизация:** На ходу мягко подтягивается к `EST` (Soft Sync), на стоянке жестко сбрасывается в `EST`.
3.  **`EST` (Оценка / Estimation):**
    *   **Источник:** `MODEL` + Коррекция по Лидару (триангуляция столбов).
    *   **Свойства:** Абсолютная точность (привязка к карте), но подвержена "шуму" (скачкам) измерений.
    *   **Назначение:** Главная координата для глобальной навигации.

### 2.2. Компенсация Латентности (Latency Compensation)
**Проблема:** Лидар выдает данные с задержкой (пока просканирует, пока передаст, пока рассчитает). К моменту получения координат робот уже уехал дальше. Это вызывало постоянное отставание `EST` от реальности и перелеты при остановке.

**Решение:** Алгоритм **Rate-Limited Fuser с предикцией**.
В момент получения измерения (`meas`) мы "переносим" его в настоящее время:
$$ P_{proj} = P_{meas} + V_{model} \times L $$
*   $L$ (Латентность) экспериментально установлена в **0.15 сек**.
*   Это устранило систематическую ошибку отставания на поворотах и торможениях.

### 2.3. Гибридная Стабилизация (ZUPT)
Для борьбы с шумом лидара мы реализовали разное поведение в зависимости от состояния робота:

1.  **В движении (Motion):**
    *   `EST` корректируется к лидару через **Gain = 0.333** (исправляем 33% ошибки за такт).
    *   `MODEL` мягко тянется за `EST` с коэффициентом **k=0.025** (2.5%). Это убирает глобальный дрейф, но сохраняет плавность модели, фильтруя "пилу" лидара.
2.  **На стоянке (Drift):**
    *   Включается **Медианный фильтр**. Мы накапливаем буфер из 100 измерений лидара.
    *   `EST` фиксируется в медианном значении (исключает случайные выбросы/блики).
    *   Через 1.9 секунды простоя происходит **Hard Sync**: `MODEL` жестко приравнивается к стабилизированной `EST`.

---

## 3. Узел Управления (`control_node`)

Реализует логику движения. Главное достижение — система **"Бесшовного переключения режимов" (Seamless Mode Switching)**.

### 3.1. Три Режима Управления
В зависимости от типа команды G-кода, робот выбирает оптимальный источник данных:

1.  **Режим `EST` (Global):**
    *   **Для:** Длинных проездов (`G2 X... Y...`).
    *   **Логика:** Используем `g_poseC = EST`.
    *   **Цель:** Приехать точно в глобальную координату, компенсируя накопленную ошибку колес.
2.  **Режим `MODEL` (Smooth Gyro):**
    *   **Для:** Поворотов на месте (`G1 A...`).
    *   **Логика:** Используем `g_poseC = MODEL + Offset`.
    *   **Цель:** Идеально плавный поворот. Гироскоп чувствует вращение лучше лидара (который размывается в динамике).
3.  **Режим `ODOM` (Blind Precision):**
    *   **Для:** Микро-маневров пера (`G2 L...`, отъезды на 4.5 см).
    *   **Логика:** Используем `g_poseC = ODOM + Offset`.
    *   **Цель:** Проехать ровно заданное расстояние по энкодерам. Игнорируем шум лидара, который на дистанции 4 см может дать погрешность 50%.

### 3.2. Механизм "Offset" (Оффсет)
Чтобы при переключении режимов (например, с `EST` на `ODOM`) робот не дергался из-за разницы координат:
1.  В момент начала команды запоминаем разницу:
    $$ Offset = Pos_{Current} - Pos_{NewMode} $$
2.  Во время выполнения команды подменяем координаты для контроллера:
    $$ Pos_{Virtual} = Pos_{NewMode} + Offset $$
Это создает иллюзию непрерывности координат для PID-регуляторов.

### 3.3. L1 Guidance Controller
Используется для удержания траектории (езда по линии).
*   **Дистанция упреждения ($L_{lookahead}$):** Настроена на **0.15 м**. Это обеспечивает "агрессивную" реакцию на отклонения, позволяя роботу быстро возвращаться на траекторию даже на коротких отрезках.
*   **Лимиты ($\omega_{max}$):** Подняты до **0.5 рад/с**, чтобы робот не был "ленивым" при коррекции ошибок.

### 3.4. Динамика и Остановка
Реализована стратегия **"Подкрадывания" (Creep Speed)**:
1.  **Тормозной путь:** Рассчитывается так, чтобы скорость упала в ноль за **2 мм (margin)** до цели.
2.  **Минимальная скорость:** Если скорость падает ниже 0.005 м/с, робот продолжает "ползти" к цели.
3.  **Условие финиша:**
    *   Либо ошибка < 1 мм.
    *   Либо обнаружен **рост ошибки** (Trend Checker) — защита от проезда мимо цели.
    *   *Важно:* Для режима `ODOM` (L-команды) Trend Checker отключен, робот едет "слепо" до цифры на энкодере.

---

## 4. G-Code и Работа с инструментом

### 4.1. Проблема смещения маркера (Tool Offset)
Маркер смещен относительно центра вращения робота на **4.5 см** вперед.
Мы решили не усложнять контроллер, а вынести эту логику в **Генератор/Парсер**.

**Алгоритм рисования угла:**
1.  Приехать **Центром** в точку угла. (Маркер висит в воздухе за 4.5 см от угла).
2.  Повернуться.
3.  Сдать назад на 4.5 см (`G2 L=0.045`). Теперь маркер над точкой.
4.  Опустить перо (`M3`).
5.  Поехать вперед.

### 4.2. Парсер
Реализована поддержка команд `G10` для установки рабочей системы координат.
*   Робот физически приезжает в точку старта.
*   Обнуляет свои локальные координаты (через глобальный `g_coord_offset`).
*   Запускает сбор статистики.

---

## 5. Статистика и Аналитика (`SystemStatistics`)

Создан мощный инструмент отладки, который разделяет ошибки на две категории:
1.  **Active Motion:** Насколько точно робот проехал заданный маршрут.
2.  **Passive Drift:** Насколько координаты "уплыли", пока робот стоял.

**Текущие показатели (по последним логам):**
*   **Точность на маршруте (Active):** Погрешность **< 1%** (на дистанции 12 метров ошибка ~3 см).
*   **Дрейф (Passive):** Около **0.5 см** на одну остановку (это предел точности лидара).
*   **Одометрия:** Имеет систематическую погрешность около **1.7%** (пробуксовка/диаметр колес), которая успешно компенсируется алгоритмами `EST`.

---

## 6. Итоговые выводы и "Золотые настройки"

Мы пришли к следующим оптимальным настройкам (хранятся в коде):

| Параметр | Значение | Обоснование |
| :--- | :--- | :--- |
| `lidar_latency_L` | **0.15 с** | Компенсирует лаг обработки, убирает перелеты. |
| `L_lookahead` | **0.15 м** | Обеспечивает точное следование линии на малых скоростях. |
| `max_omega` | **0.5 рад/с** | Позволяет резко подруливать при сходе с траектории. |
| `gain` (Fuser) | **0.333** | Сглаживает шум лидара, убирает "зубья" на графике. |
| `k_soft_sync` | **0.025** | Мягко тянет модель к карте (2.5% за такт), исправляя дрейф. |
| `margin` (Brake) | **0.002 м** | Торможение целится за 2 мм до финиша, чтобы исключить удар. |

### Статус проекта
Система полностью функциональна.
*   **Проблема рывков:** Решена (Offset + Soft Sync).
*   **Проблема перелетов:** Решена (Latency Compensation + Trend Checker).
*   **Проблема точности чертежа:** Решена (Hybrid Control Modes: Odom для мелких деталей, Est для длинных линий).

Робот готов к выполнению сложных чертежных задач с высокой точностью.
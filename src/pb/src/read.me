У тебя набрался солидный набор параметров. Чтобы ты не запутался, я разделил их по **нодам** и по **физическому смыслу**.

Всего у тебя **12 ключевых "крутилок"**, которые влияют на поведение робота.

---

### 1. `pos_node` (Где я?)
*Отвечает за точность координат и плавность линий на графике.*

#### А. Слияние и Задержки (Самое важное)
1.  **`lidar_latency_L`** (в `main.cpp`)
    *   *Сейчас:* `0.15` (сек).
    *   *Что делает:* Компенсирует отставание лидара.
    *   *Настройка:* Если робот переезжает цель (по `est`), увеличивай. Если недоезжает — уменьшай.
2.  **`gain`** (в `localizer.h`, внутри `RateLimitedLocalizer`)
    *   *Сейчас:* `0.333` (33%).
    *   *Что делает:* Насколько агрессивно оценка (`est`) прыгает к данным лидара.
    *   *Настройка:* Если `est` слишком "зубастая" (пила) — уменьшай (до 0.1). Если вялая — увеличивай.
3.  **`max_angle_step`** (в `localizer.h`)
    *   *Сейчас:* `1.0` (град).
    *   *Что делает:* Лимит скорости исправления ошибки угла. Защита от телепортации при сбое лидара.

#### Б. Синхронизация (Связь Est и Model)
4.  **`k_motion` / `k_soft_sync`** (в `main.cpp`, блок Soft Sync)
    *   *Сейчас:* `0.025` (2.5%).
    *   *Что делает:* Насколько сильно `model` (одометрия) тянется к `est` на ходу.
    *   *Настройка:* Должен быть равен примерной погрешности твоей механики. Если поставить `0`, модель улетит в бесконечность.
5.  **Таймеры стоянки** (в `main.cpp`)
    *   *Сейчас:* `0.5с` (старт медианы), `1.9с` (сброс модели).
    *   *Что делает:* Определяет, как долго робот должен стоять неподвижно, чтобы мы поверили, что позиция железобетонная, и сбросили дрейф.

#### В. Физика сенсоров (IMU + Колеса)
6.  **`alpha`** (в `code.h`, Leaky Integrator)
    *   *Сейчас:* `0.98`.
    *   *Что делает:* Борьба с дрейфом акселерометра. 98% верим инерции, 2% верим, что скорость колес верна.
7.  **Веса слияния** (в `code.h`, `calcTwistFused`)
    *   *Сейчас:* `0.05` / `0.95` (для угла).
    *   *Что делает:* Кому верим больше: гироскопу или энкодерам.

---

### 2. `control_node` (Куда ехать?)
*Отвечает за то, как робот исполняет команды.*

#### А. Точность остановки
8.  **`margin`** (в `code.h`, `calculate_max_safe_speed`)
    *   *Сейчас:* `0.01` (10 мм).
    *   *Что делает:* Зона "подкрадывания". За 10 мм до цели робот сбрасывает расчетную скорость в 0 и ползет на минималке.
9.  **`minVectorMistake` / `minAngleMistake`** (в `code.h`)
    *   *Сейчас:* `0.001` м (1 мм) / `0.02` град.
    *   *Что делает:* Условие финиша.

#### Б. Динамика (Разгон/Торможение)
10. **`max_angular_acceleration_degs2`** (в `code.h`)
    *   *Сейчас:* `15.0` (град/с²).
    *   *Что делает:* Плавность старта и торможения при поворотах. Меньше = плавнее, но медленнее.
11. **`max_deceleration`** (в `code.h`)
    *   *Сейчас:* `0.1` (м/с²).
    *   *Что делает:* Тормозной путь при езде прямо. Если робот пролетает цель и резко бьет по тормозам — это число слишком большое для твоего веса/пола.

#### В. Рулежка (L1 Controller)
12. **`L_lookahead`** (в `code.h`, `workVector`)
    *   *Сейчас:* `0.4` (метра).
    *   *Что делает:* Как далеко вперед смотрит робот при езде по прямой.
    *   *Настройка:*
        *   Мало (0.1): Робот будет вилять, пытаясь вернуться на линию каждые 10 см.
        *   Много (1.0): Робот будет ехать очень плавно, но может "срезать углы" или медленно возвращаться на траекторию, если его сдвинуть. `0.4` — золотая середина для комнатных скоростей.

### Итого
Самые важные для тебя сейчас (для точности чертежа):
1.  **`lidar_latency_L`** (чтобы не было перелетов).
2.  **`DISTANCE_WHEELS`** (в конфиге, чтобы 90 градусов были 90 градусами).
3.  **`margin`** (чтобы мягко доезжать до точки).